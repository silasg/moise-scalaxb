// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package moise
    
/**
usage:
import scalaxb._
import moise._

val obj = fromXML[Foo](node)
val document = toXML[Foo](obj, "foo", defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "http://moise.sourceforge.net/os",
    Some("moise") -> "http://moise.sourceforge.net/os",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val MoiseOsTypeFormat: scalaxb.XMLFormat[moise.OsType] = new DefaultMoiseOsTypeFormat {}
  implicit lazy val MoiseRoledefinitionsFormat: scalaxb.XMLFormat[moise.Roledefinitions] = new DefaultMoiseRoledefinitionsFormat {}
  implicit lazy val MoiseLinktypeFormat: scalaxb.XMLFormat[moise.Linktype] = new DefaultMoiseLinktypeFormat {}
  implicit lazy val MoiseLinktypesFormat: scalaxb.XMLFormat[moise.Linktypes] = new DefaultMoiseLinktypesFormat {}
  implicit lazy val MoiseSsTypeFormat: scalaxb.XMLFormat[moise.SsType] = new DefaultMoiseSsTypeFormat {}
  implicit lazy val MoiseGoalFormat: scalaxb.XMLFormat[moise.Goal] = new DefaultMoiseGoalFormat {}
  implicit lazy val MoisePreferredFormat: scalaxb.XMLFormat[moise.Preferred] = new DefaultMoisePreferredFormat {}
  implicit lazy val MoiseMissionFormat: scalaxb.XMLFormat[moise.Mission] = new DefaultMoiseMissionFormat {}
  implicit lazy val MoiseSchemeFormat: scalaxb.XMLFormat[moise.Scheme] = new DefaultMoiseSchemeFormat {}
  implicit lazy val MoiseFsTypeFormat: scalaxb.XMLFormat[moise.FsType] = new DefaultMoiseFsTypeFormat {}
  implicit lazy val MoiseNormFormat: scalaxb.XMLFormat[moise.Norm] = new DefaultMoiseNormFormat {}
  implicit lazy val MoiseNsTypeFormat: scalaxb.XMLFormat[moise.NsType] = new DefaultMoiseNsTypeFormat {}
  implicit lazy val MoisePropertyFormat: scalaxb.XMLFormat[moise.Property] = new DefaultMoisePropertyFormat {}
  implicit lazy val MoisePropertiesTypeFormat: scalaxb.XMLFormat[moise.PropertiesType] = new DefaultMoisePropertiesTypeFormat {}
  implicit lazy val MoisePropertiesTypeSequence1Format: scalaxb.XMLFormat[moise.PropertiesTypeSequence1] = new DefaultMoisePropertiesTypeSequence1Format {}
  implicit lazy val MoiseExtendsFormat: scalaxb.XMLFormat[moise.Extends] = new DefaultMoiseExtendsFormat {}
  implicit lazy val MoiseRoleDefTypeFormat: scalaxb.XMLFormat[moise.RoleDefType] = new DefaultMoiseRoleDefTypeFormat {}
  implicit lazy val MoiseScopeTypeFormat: scalaxb.XMLFormat[moise.ScopeType] = new DefaultMoiseScopeTypeFormat {}
  implicit lazy val MoiseCardinalityObjectTypeFormat: scalaxb.XMLFormat[moise.CardinalityObjectType] = new DefaultMoiseCardinalityObjectTypeFormat {}
  implicit lazy val MoiseRoleFormat: scalaxb.XMLFormat[moise.Role] = new DefaultMoiseRoleFormat {}
  implicit lazy val MoiseRolesFormat: scalaxb.XMLFormat[moise.Roles] = new DefaultMoiseRolesFormat {}
  implicit lazy val MoiseLinkFormat: scalaxb.XMLFormat[moise.Link] = new DefaultMoiseLinkFormat {}
  implicit lazy val MoiseLinksFormat: scalaxb.XMLFormat[moise.Links] = new DefaultMoiseLinksFormat {}
  implicit lazy val MoiseIncludegroupspecificationFormat: scalaxb.XMLFormat[moise.Includegroupspecification] = new DefaultMoiseIncludegroupspecificationFormat {}
  implicit lazy val MoiseSubgroupsFormat: scalaxb.XMLFormat[moise.Subgroups] = new DefaultMoiseSubgroupsFormat {}
  implicit lazy val MoiseCardinalityFormat: scalaxb.XMLFormat[moise.Cardinality] = new DefaultMoiseCardinalityFormat {}
  implicit lazy val MoiseCompatibilityFormat: scalaxb.XMLFormat[moise.Compatibility] = new DefaultMoiseCompatibilityFormat {}
  implicit lazy val MoiseFormationconstraintsFormat: scalaxb.XMLFormat[moise.Formationconstraints] = new DefaultMoiseFormationconstraintsFormat {}
  implicit lazy val MoiseGroupSpecificationTypeFormat: scalaxb.XMLFormat[moise.GroupSpecificationType] = new DefaultMoiseGroupSpecificationTypeFormat {}
  implicit lazy val MoisePlanTypeFormat: scalaxb.XMLFormat[moise.PlanType] = new DefaultMoisePlanTypeFormat {}
  implicit lazy val MoiseGoalDefTypeFormat: scalaxb.XMLFormat[moise.GoalDefType] = new DefaultMoiseGoalDefTypeFormat {}
  implicit lazy val MoiseArgumentTypeFormat: scalaxb.XMLFormat[moise.ArgumentType] = new DefaultMoiseArgumentTypeFormat {}
  implicit lazy val MoisePlanOperatorTypeFormat: scalaxb.XMLFormat[moise.PlanOperatorType] = new DefaultMoisePlanOperatorTypeFormat {}
  implicit lazy val MoiseGoalTypeFormat: scalaxb.XMLFormat[moise.GoalType] = new DefaultMoiseGoalTypeFormat {}

  trait DefaultMoiseOsTypeFormat extends scalaxb.ElemNameParser[moise.OsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("osType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.OsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      (scalaxb.ElemName(targetNamespace, "structural-specification")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "functional-specification")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "normative-specification")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      moise.OsType(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[moise.SsType](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[moise.FsType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[moise.NsType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@os-version"), scalaxb.ElemName(node) :: stack)) }
    
    override def writesAttribute(__obj: moise.OsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "os-version", __obj.osversion.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.OsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[moise.SsType](__obj.structuralspecification, targetNamespace, Some("structural-specification"), __scope, false),
        __obj.functionalspecification map { scalaxb.toXML[moise.FsType](_, targetNamespace, Some("functional-specification"), __scope, false) } getOrElse {Nil},
        __obj.normativespecification map { scalaxb.toXML[moise.NsType](_, targetNamespace, Some("normative-specification"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMoiseRoledefinitionsFormat extends scalaxb.ElemNameParser[moise.Roledefinitions] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Roledefinitions] =
      rep(scalaxb.ElemName(targetNamespace, "role")) ^^
      { case p1 =>
      moise.Roledefinitions(p1.toSeq map { scalaxb.fromXML[moise.RoleDefType](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: moise.Roledefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.role flatMap { scalaxb.toXML[moise.RoleDefType](_, targetNamespace, Some("role"), __scope, false) })

  }

  trait DefaultMoiseLinktypeFormat extends scalaxb.XMLFormat[moise.Linktype] with scalaxb.CanWriteChildNodes[moise.Linktype] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Linktype] = seq match {
      case node: scala.xml.Node => Right(moise.Linktype(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Linktype, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.Linktype, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseLinktypesFormat extends scalaxb.ElemNameParser[moise.Linktypes] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Linktypes] =
      rep(scalaxb.ElemName(targetNamespace, "link-type")) ^^
      { case p1 =>
      moise.Linktypes(p1.toSeq map { scalaxb.fromXML[moise.Linktype](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: moise.Linktypes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.linktype flatMap { scalaxb.toXML[moise.Linktype](_, targetNamespace, Some("link-type"), __scope, false) })

  }

  trait DefaultMoiseSsTypeFormat extends scalaxb.ElemNameParser[moise.SsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("ssType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.SsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "role-definitions")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "link-types")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "group-specification")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      moise.SsType(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[moise.Roledefinitions](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[moise.Linktypes](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[moise.GroupSpecificationType](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: moise.SsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.roledefinitions map { scalaxb.toXML[moise.Roledefinitions](_, targetNamespace, Some("role-definitions"), __scope, false) } getOrElse {Nil},
        __obj.linktypes map { scalaxb.toXML[moise.Linktypes](_, targetNamespace, Some("link-types"), __scope, false) } getOrElse {Nil},
        __obj.groupspecification map { scalaxb.toXML[moise.GroupSpecificationType](_, targetNamespace, Some("group-specification"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMoiseGoalFormat extends scalaxb.XMLFormat[moise.Goal] with scalaxb.CanWriteChildNodes[moise.Goal] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Goal] = seq match {
      case node: scala.xml.Node => Right(moise.Goal(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Goal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.Goal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoisePreferredFormat extends scalaxb.XMLFormat[moise.Preferred] with scalaxb.CanWriteChildNodes[moise.Preferred] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Preferred] = seq match {
      case node: scala.xml.Node => Right(moise.Preferred(scalaxb.fromXML[String]((node \ "@mission"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Preferred, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "mission", __obj.mission.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.Preferred, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseMissionFormat extends scalaxb.ElemNameParser[moise.Mission] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Mission] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "goal")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "preferred")) ^^
      { case p1 ~ p2 ~ p3 =>
      moise.Mission(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.Goal](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[moise.Preferred](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: moise.Mission, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Mission, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.goal flatMap { scalaxb.toXML[moise.Goal](_, targetNamespace, Some("goal"), __scope, false) },
        __obj.preferred flatMap { scalaxb.toXML[moise.Preferred](_, targetNamespace, Some("preferred"), __scope, false) })

  }

  trait DefaultMoiseSchemeFormat extends scalaxb.ElemNameParser[moise.Scheme] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Scheme] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      (scalaxb.ElemName(targetNamespace, "goal")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "mission")) ^^
      { case p1 ~ p2 ~ p3 =>
      moise.Scheme(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[moise.GoalDefType](p2, scalaxb.ElemName(node) :: stack),
        p3.toSeq map { scalaxb.fromXML[moise.Mission](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@monitoring-scheme").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: moise.Scheme, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.monitoringscheme foreach { x => attr = scala.xml.Attribute(null, "monitoring-scheme", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Scheme, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[moise.GoalDefType](__obj.goal, targetNamespace, Some("goal"), __scope, false),
        __obj.mission flatMap { scalaxb.toXML[moise.Mission](_, targetNamespace, Some("mission"), __scope, false) })

  }

  trait DefaultMoiseFsTypeFormat extends scalaxb.ElemNameParser[moise.FsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("fsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.FsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "scheme")) ^^
      { case p1 ~ p2 =>
      moise.FsType(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.Scheme](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: moise.FsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.scheme flatMap { scalaxb.toXML[moise.Scheme](_, targetNamespace, Some("scheme"), __scope, false) })

  }

  trait DefaultMoiseNormFormat extends scalaxb.XMLFormat[moise.Norm] with scalaxb.CanWriteChildNodes[moise.Norm] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Norm] = seq match {
      case node: scala.xml.Node => Right(moise.Norm(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@condition").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@role"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@mission"), scalaxb.ElemName(node) :: stack),
        (node \ "@time-constraint").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Norm, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.condition foreach { x => attr = scala.xml.Attribute(null, "condition", x.toString, attr) }
      attr = scala.xml.Attribute(null, "role", __obj.role.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr = scala.xml.Attribute(null, "mission", __obj.mission.toString, attr)
      __obj.timeconstraint foreach { x => attr = scala.xml.Attribute(null, "time-constraint", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Norm, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseNsTypeFormat extends scalaxb.ElemNameParser[moise.NsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("nsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.NsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "norm")) ^^
      { case p1 ~ p2 =>
      moise.NsType(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.Norm](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: moise.NsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.norm flatMap { scalaxb.toXML[moise.Norm](_, targetNamespace, Some("norm"), __scope, false) })

  }

  trait DefaultMoisePropertyFormat extends scalaxb.XMLFormat[moise.Property] with scalaxb.CanWriteChildNodes[moise.Property] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Property] = seq match {
      case node: scala.xml.Node => Right(moise.Property(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@value"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Property, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.Property, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoisePropertiesTypeFormat extends scalaxb.ElemNameParser[moise.PropertiesType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("propertiesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.PropertiesType] =
      rep(((scalaxb.ElemName(targetNamespace, "property"))) ^^ 
        { case p1 => moise.PropertiesTypeSequence1(scalaxb.fromXML[moise.Property](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      moise.PropertiesType(p1.toSeq: _*) }
    
    def writesChildNodes(__obj: moise.PropertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.propertiestypesequence1 flatMap { scalaxb.toXML[moise.PropertiesTypeSequence1](_, None, Some("propertiestypesequence1"), __scope, false) })

  }

  trait DefaultMoisePropertiesTypeSequence1Format extends scalaxb.XMLFormat[moise.PropertiesTypeSequence1] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.PropertiesTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: moise.PropertiesTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[moise.Property](__obj.property, targetNamespace, Some("property"), __scope, false)


  }

  trait DefaultMoiseExtendsFormat extends scalaxb.XMLFormat[moise.Extends] with scalaxb.CanWriteChildNodes[moise.Extends] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Extends] = seq match {
      case node: scala.xml.Node => Right(moise.Extends((node \ "@role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Extends, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.role foreach { x => attr = scala.xml.Attribute(null, "role", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Extends, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseRoleDefTypeFormat extends scalaxb.ElemNameParser[moise.RoleDefType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("roleDefType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.RoleDefType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "extends")) ^^
      { case p1 ~ p2 =>
      moise.RoleDefType(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.Extends](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) }
    
    override def writesAttribute(__obj: moise.RoleDefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.RoleDefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.extendsValue flatMap { scalaxb.toXML[moise.Extends](_, targetNamespace, Some("extends"), __scope, false) })

  }

  def buildMoiseScopeTypeFormat = new DefaultMoiseScopeTypeFormat {}
  trait DefaultMoiseScopeTypeFormat extends scalaxb.XMLFormat[moise.ScopeType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.ScopeType] =
      Right(moise.ScopeType.fromString(seq.text))
    
    def writes(__obj: moise.ScopeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildMoiseCardinalityObjectTypeFormat = new DefaultMoiseCardinalityObjectTypeFormat {}
  trait DefaultMoiseCardinalityObjectTypeFormat extends scalaxb.XMLFormat[moise.CardinalityObjectType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.CardinalityObjectType] =
      Right(moise.CardinalityObjectType.fromString(seq.text))
    
    def writes(__obj: moise.CardinalityObjectType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultMoiseRoleFormat extends scalaxb.XMLFormat[moise.Role] with scalaxb.CanWriteChildNodes[moise.Role] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Role] = seq match {
      case node: scala.xml.Node => Right(moise.Role((node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Role, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Role, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseRolesFormat extends scalaxb.ElemNameParser[moise.Roles] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Roles] =
      rep(scalaxb.ElemName(targetNamespace, "role")) ^^
      { case p1 =>
      moise.Roles(p1.toSeq map { scalaxb.fromXML[moise.Role](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: moise.Roles, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.role flatMap { scalaxb.toXML[moise.Role](_, targetNamespace, Some("role"), __scope, false) })

  }

  trait DefaultMoiseLinkFormat extends scalaxb.XMLFormat[moise.Link] with scalaxb.CanWriteChildNodes[moise.Link] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Link] = seq match {
      case node: scala.xml.Node => Right(moise.Link((node \ "@from").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@to").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@scope").headOption map { scalaxb.fromXML[moise.ScopeType](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[moise.ScopeType](scala.xml.Text("intra-group"), scalaxb.ElemName(node) :: stack) },
        (node \ "@extends-sub-groups").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@bi-dir").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Link, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.from foreach { x => attr = scala.xml.Attribute(null, "from", x.toString, attr) }
      __obj.to foreach { x => attr = scala.xml.Attribute(null, "to", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      if (__obj.scope.toString != "intra-group") attr = scala.xml.Attribute(null, "scope", __obj.scope.toString, attr)
      if (__obj.extendssubgroups.toString != "false") attr = scala.xml.Attribute(null, "extends-sub-groups", __obj.extendssubgroups.toString, attr)
      if (__obj.bidir.toString != "false") attr = scala.xml.Attribute(null, "bi-dir", __obj.bidir.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.Link, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseLinksFormat extends scalaxb.ElemNameParser[moise.Links] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Links] =
      rep(scalaxb.ElemName(targetNamespace, "link")) ^^
      { case p1 =>
      moise.Links(p1.toSeq map { scalaxb.fromXML[moise.Link](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: moise.Links, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.link flatMap { scalaxb.toXML[moise.Link](_, targetNamespace, Some("link"), __scope, false) })

  }

  trait DefaultMoiseIncludegroupspecificationFormat extends scalaxb.XMLFormat[moise.Includegroupspecification] with scalaxb.CanWriteChildNodes[moise.Includegroupspecification] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Includegroupspecification] = seq match {
      case node: scala.xml.Node => Right(moise.Includegroupspecification((node \ "@uri").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Includegroupspecification, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.uri foreach { x => attr = scala.xml.Attribute(null, "uri", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Includegroupspecification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseSubgroupsFormat extends scalaxb.ElemNameParser[moise.Subgroups] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Subgroups] =
      rep(scalaxb.ElemName(targetNamespace, "include-group-specification")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "group-specification")) ^^
      { case p1 ~ p2 =>
      moise.Subgroups(p1.toSeq map { scalaxb.fromXML[moise.Includegroupspecification](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.GroupSpecificationType](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: moise.Subgroups, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.includegroupspecification flatMap { scalaxb.toXML[moise.Includegroupspecification](_, targetNamespace, Some("include-group-specification"), __scope, false) },
        __obj.groupspecification flatMap { scalaxb.toXML[moise.GroupSpecificationType](_, targetNamespace, Some("group-specification"), __scope, false) })

  }

  trait DefaultMoiseCardinalityFormat extends scalaxb.XMLFormat[moise.Cardinality] with scalaxb.CanWriteChildNodes[moise.Cardinality] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Cardinality] = seq match {
      case node: scala.xml.Node => Right(moise.Cardinality((node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[moise.CardinalityObjectType]((node \ "@object"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Cardinality, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      attr = scala.xml.Attribute(null, "object", __obj.objectValue.toString, attr)
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: moise.Cardinality, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseCompatibilityFormat extends scalaxb.XMLFormat[moise.Compatibility] with scalaxb.CanWriteChildNodes[moise.Compatibility] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.Compatibility] = seq match {
      case node: scala.xml.Node => Right(moise.Compatibility(scalaxb.fromXML[String]((node \ "@from"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@to"), scalaxb.ElemName(node) :: stack),
        (node \ "@scope").headOption map { scalaxb.fromXML[moise.ScopeType](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[moise.ScopeType](scala.xml.Text("intra-group"), scalaxb.ElemName(node) :: stack) },
        (node \ "@extends-sub-groups").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@bi-dir").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.Compatibility, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "from", __obj.from.toString, attr)
      attr = scala.xml.Attribute(null, "to", __obj.to.toString, attr)
      if (__obj.scope.toString != "intra-group") attr = scala.xml.Attribute(null, "scope", __obj.scope.toString, attr)
      if (__obj.extendssubgroups.toString != "false") attr = scala.xml.Attribute(null, "extends-sub-groups", __obj.extendssubgroups.toString, attr)
      if (__obj.bidir.toString != "false") attr = scala.xml.Attribute(null, "bi-dir", __obj.bidir.toString, attr)
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.Compatibility, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMoiseFormationconstraintsFormat extends scalaxb.ElemNameParser[moise.Formationconstraints] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.Formationconstraints] =
      rep(scalaxb.ElemName(targetNamespace, "cardinality")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "compatibility")) ^^
      { case p1 ~ p2 =>
      moise.Formationconstraints(p1.toSeq map { scalaxb.fromXML[moise.Cardinality](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.Compatibility](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: moise.Formationconstraints, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.cardinality flatMap { scalaxb.toXML[moise.Cardinality](_, targetNamespace, Some("cardinality"), __scope, false) },
        __obj.compatibility flatMap { scalaxb.toXML[moise.Compatibility](_, targetNamespace, Some("compatibility"), __scope, false) })

  }

  trait DefaultMoiseGroupSpecificationTypeFormat extends scalaxb.ElemNameParser[moise.GroupSpecificationType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("groupSpecificationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.GroupSpecificationType] =
      opt(scalaxb.ElemName(targetNamespace, "roles")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "links")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "sub-groups")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "formation-constraints")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      moise.GroupSpecificationType(p1.headOption map { scalaxb.fromXML[moise.Roles](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[moise.Links](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[moise.Subgroups](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[moise.Formationconstraints](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@monitoring-scheme").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: moise.GroupSpecificationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      __obj.monitoringscheme foreach { x => attr = scala.xml.Attribute(null, "monitoring-scheme", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.GroupSpecificationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.roles map { scalaxb.toXML[moise.Roles](_, targetNamespace, Some("roles"), __scope, false) } getOrElse {Nil},
        __obj.links map { scalaxb.toXML[moise.Links](_, targetNamespace, Some("links"), __scope, false) } getOrElse {Nil},
        __obj.subgroups flatMap { scalaxb.toXML[moise.Subgroups](_, targetNamespace, Some("sub-groups"), __scope, false) },
        __obj.formationconstraints map { scalaxb.toXML[moise.Formationconstraints](_, targetNamespace, Some("formation-constraints"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMoisePlanTypeFormat extends scalaxb.ElemNameParser[moise.PlanType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("planType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.PlanType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "goal")) ^^
      { case p1 ~ p2 =>
      moise.PlanType(p1.headOption map { scalaxb.fromXML[moise.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[moise.GoalDefType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[moise.PlanOperatorType]((node \ "@operator"), scalaxb.ElemName(node) :: stack),
        (node \ "@success-rate").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: moise.PlanType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "operator", __obj.operator.toString, attr)
      __obj.successrate foreach { x => attr = scala.xml.Attribute(null, "success-rate", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.PlanType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[moise.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.goal flatMap { scalaxb.toXML[moise.GoalDefType](_, targetNamespace, Some("goal"), __scope, false) })

  }

  trait DefaultMoiseGoalDefTypeFormat extends scalaxb.ElemNameParser[moise.GoalDefType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("goalDefType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[moise.GoalDefType] =
      rep(scalaxb.ElemName(targetNamespace, "argument")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "plan")) ^^
      { case p1 ~ p2 =>
      moise.GoalDefType(p1.toSeq map { scalaxb.fromXML[moise.ArgumentType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[moise.PlanType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ds").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[moise.GoalType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ttf").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: moise.GoalDefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.ds foreach { x => attr = scala.xml.Attribute(null, "ds", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.ttf foreach { x => attr = scala.xml.Attribute(null, "ttf", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.GoalDefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.argument flatMap { scalaxb.toXML[moise.ArgumentType](_, targetNamespace, Some("argument"), __scope, false) },
        __obj.plan map { scalaxb.toXML[moise.PlanType](_, targetNamespace, Some("plan"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMoiseArgumentTypeFormat extends scalaxb.XMLFormat[moise.ArgumentType] with scalaxb.CanWriteChildNodes[moise.ArgumentType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.ArgumentType] = seq match {
      case node: scala.xml.Node => Right(moise.ArgumentType(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@value").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: moise.ArgumentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.value foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: moise.ArgumentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildMoisePlanOperatorTypeFormat = new DefaultMoisePlanOperatorTypeFormat {}
  trait DefaultMoisePlanOperatorTypeFormat extends scalaxb.XMLFormat[moise.PlanOperatorType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.PlanOperatorType] =
      Right(moise.PlanOperatorType.fromString(seq.text))
    
    def writes(__obj: moise.PlanOperatorType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildMoiseGoalTypeFormat = new DefaultMoiseGoalTypeFormat {}
  trait DefaultMoiseGoalTypeFormat extends scalaxb.XMLFormat[moise.GoalType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, moise.GoalType] =
      Right(moise.GoalType.fromString(seq.text))
    
    def writes(__obj: moise.GoalType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }


}

