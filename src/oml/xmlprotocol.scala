// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package oml
    
/**
usage:
import scalaxb._
import oml._

val obj = fromXML[Foo](node)
val document = toXML[Foo](obj, "foo", defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "http://moise.sourceforge.net/os",
    Some("moise") -> "http://moise.sourceforge.net/os",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val omlOsTypeFormat: scalaxb.XMLFormat[oml.OsType] = new DefaultomlOsTypeFormat {}
  implicit lazy val omlRoledefinitionsFormat: scalaxb.XMLFormat[oml.Roledefinitions] = new DefaultomlRoledefinitionsFormat {}
  implicit lazy val omlLinktypeFormat: scalaxb.XMLFormat[oml.Linktype] = new DefaultomlLinktypeFormat {}
  implicit lazy val omlLinktypesFormat: scalaxb.XMLFormat[oml.Linktypes] = new DefaultomlLinktypesFormat {}
  implicit lazy val omlSsTypeFormat: scalaxb.XMLFormat[oml.SsType] = new DefaultomlSsTypeFormat {}
  implicit lazy val omlGoalFormat: scalaxb.XMLFormat[oml.Goal] = new DefaultomlGoalFormat {}
  implicit lazy val omlPreferredFormat: scalaxb.XMLFormat[oml.Preferred] = new DefaultomlPreferredFormat {}
  implicit lazy val omlMissionFormat: scalaxb.XMLFormat[oml.Mission] = new DefaultomlMissionFormat {}
  implicit lazy val omlSchemeFormat: scalaxb.XMLFormat[oml.Scheme] = new DefaultomlSchemeFormat {}
  implicit lazy val omlFsTypeFormat: scalaxb.XMLFormat[oml.FsType] = new DefaultomlFsTypeFormat {}
  implicit lazy val omlNormFormat: scalaxb.XMLFormat[oml.Norm] = new DefaultomlNormFormat {}
  implicit lazy val omlNsTypeFormat: scalaxb.XMLFormat[oml.NsType] = new DefaultomlNsTypeFormat {}
  implicit lazy val omlPropertyFormat: scalaxb.XMLFormat[oml.Property] = new DefaultomlPropertyFormat {}
  implicit lazy val omlPropertiesTypeFormat: scalaxb.XMLFormat[oml.PropertiesType] = new DefaultomlPropertiesTypeFormat {}
  implicit lazy val omlPropertiesTypeSequence1Format: scalaxb.XMLFormat[oml.PropertiesTypeSequence1] = new DefaultomlPropertiesTypeSequence1Format {}
  implicit lazy val omlExtendsFormat: scalaxb.XMLFormat[oml.Extends] = new DefaultomlExtendsFormat {}
  implicit lazy val omlRoleDefTypeFormat: scalaxb.XMLFormat[oml.RoleDefType] = new DefaultomlRoleDefTypeFormat {}
  implicit lazy val omlScopeTypeFormat: scalaxb.XMLFormat[oml.ScopeType] = new DefaultomlScopeTypeFormat {}
  implicit lazy val omlCardinalityObjectTypeFormat: scalaxb.XMLFormat[oml.CardinalityObjectType] = new DefaultomlCardinalityObjectTypeFormat {}
  implicit lazy val omlRoleFormat: scalaxb.XMLFormat[oml.Role] = new DefaultomlRoleFormat {}
  implicit lazy val omlRolesFormat: scalaxb.XMLFormat[oml.Roles] = new DefaultomlRolesFormat {}
  implicit lazy val omlLinkFormat: scalaxb.XMLFormat[oml.Link] = new DefaultomlLinkFormat {}
  implicit lazy val omlLinksFormat: scalaxb.XMLFormat[oml.Links] = new DefaultomlLinksFormat {}
  implicit lazy val omlIncludegroupspecificationFormat: scalaxb.XMLFormat[oml.Includegroupspecification] = new DefaultomlIncludegroupspecificationFormat {}
  implicit lazy val omlSubgroupsFormat: scalaxb.XMLFormat[oml.Subgroups] = new DefaultomlSubgroupsFormat {}
  implicit lazy val omlCardinalityFormat: scalaxb.XMLFormat[oml.Cardinality] = new DefaultomlCardinalityFormat {}
  implicit lazy val omlCompatibilityFormat: scalaxb.XMLFormat[oml.Compatibility] = new DefaultomlCompatibilityFormat {}
  implicit lazy val omlFormationconstraintsFormat: scalaxb.XMLFormat[oml.Formationconstraints] = new DefaultomlFormationconstraintsFormat {}
  implicit lazy val omlGroupSpecificationTypeFormat: scalaxb.XMLFormat[oml.GroupSpecificationType] = new DefaultomlGroupSpecificationTypeFormat {}
  implicit lazy val omlPlanTypeFormat: scalaxb.XMLFormat[oml.PlanType] = new DefaultomlPlanTypeFormat {}
  implicit lazy val omlGoalDefTypeFormat: scalaxb.XMLFormat[oml.GoalDefType] = new DefaultomlGoalDefTypeFormat {}
  implicit lazy val omlArgumentTypeFormat: scalaxb.XMLFormat[oml.ArgumentType] = new DefaultomlArgumentTypeFormat {}
  implicit lazy val omlPlanOperatorTypeFormat: scalaxb.XMLFormat[oml.PlanOperatorType] = new DefaultomlPlanOperatorTypeFormat {}
  implicit lazy val omlGoalTypeFormat: scalaxb.XMLFormat[oml.GoalType] = new DefaultomlGoalTypeFormat {}

  trait DefaultomlOsTypeFormat extends scalaxb.ElemNameParser[oml.OsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("osType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.OsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      (scalaxb.ElemName(targetNamespace, "structural-specification")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "functional-specification")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "normative-specification")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      oml.OsType(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[oml.SsType](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[oml.FsType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[oml.NsType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@os-version"), scalaxb.ElemName(node) :: stack)) }
    
    override def writesAttribute(__obj: oml.OsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "os-version", __obj.osversion.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.OsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[oml.SsType](__obj.structuralspecification, targetNamespace, Some("structural-specification"), __scope, false),
        __obj.functionalspecification map { scalaxb.toXML[oml.FsType](_, targetNamespace, Some("functional-specification"), __scope, false) } getOrElse {Nil},
        __obj.normativespecification map { scalaxb.toXML[oml.NsType](_, targetNamespace, Some("normative-specification"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultomlRoledefinitionsFormat extends scalaxb.ElemNameParser[oml.Roledefinitions] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Roledefinitions] =
      rep(scalaxb.ElemName(targetNamespace, "role")) ^^
      { case p1 =>
      oml.Roledefinitions(p1.toSeq map { scalaxb.fromXML[oml.RoleDefType](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: oml.Roledefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.role flatMap { scalaxb.toXML[oml.RoleDefType](_, targetNamespace, Some("role"), __scope, false) })

  }

  trait DefaultomlLinktypeFormat extends scalaxb.XMLFormat[oml.Linktype] with scalaxb.CanWriteChildNodes[oml.Linktype] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Linktype] = seq match {
      case node: scala.xml.Node => Right(oml.Linktype(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Linktype, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.Linktype, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlLinktypesFormat extends scalaxb.ElemNameParser[oml.Linktypes] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Linktypes] =
      rep(scalaxb.ElemName(targetNamespace, "link-type")) ^^
      { case p1 =>
      oml.Linktypes(p1.toSeq map { scalaxb.fromXML[oml.Linktype](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: oml.Linktypes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.linktype flatMap { scalaxb.toXML[oml.Linktype](_, targetNamespace, Some("link-type"), __scope, false) })

  }

  trait DefaultomlSsTypeFormat extends scalaxb.ElemNameParser[oml.SsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("ssType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.SsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "role-definitions")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "link-types")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "group-specification")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      oml.SsType(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[oml.Roledefinitions](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[oml.Linktypes](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[oml.GroupSpecificationType](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: oml.SsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.roledefinitions map { scalaxb.toXML[oml.Roledefinitions](_, targetNamespace, Some("role-definitions"), __scope, false) } getOrElse {Nil},
        __obj.linktypes map { scalaxb.toXML[oml.Linktypes](_, targetNamespace, Some("link-types"), __scope, false) } getOrElse {Nil},
        __obj.groupspecification map { scalaxb.toXML[oml.GroupSpecificationType](_, targetNamespace, Some("group-specification"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultomlGoalFormat extends scalaxb.XMLFormat[oml.Goal] with scalaxb.CanWriteChildNodes[oml.Goal] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Goal] = seq match {
      case node: scala.xml.Node => Right(oml.Goal(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Goal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.Goal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlPreferredFormat extends scalaxb.XMLFormat[oml.Preferred] with scalaxb.CanWriteChildNodes[oml.Preferred] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Preferred] = seq match {
      case node: scala.xml.Node => Right(oml.Preferred(scalaxb.fromXML[String]((node \ "@mission"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Preferred, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "mission", __obj.mission.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.Preferred, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlMissionFormat extends scalaxb.ElemNameParser[oml.Mission] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Mission] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "goal")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "preferred")) ^^
      { case p1 ~ p2 ~ p3 =>
      oml.Mission(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.Goal](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[oml.Preferred](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: oml.Mission, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Mission, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.goal flatMap { scalaxb.toXML[oml.Goal](_, targetNamespace, Some("goal"), __scope, false) },
        __obj.preferred flatMap { scalaxb.toXML[oml.Preferred](_, targetNamespace, Some("preferred"), __scope, false) })

  }

  trait DefaultomlSchemeFormat extends scalaxb.ElemNameParser[oml.Scheme] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Scheme] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      (scalaxb.ElemName(targetNamespace, "goal")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "mission")) ^^
      { case p1 ~ p2 ~ p3 =>
      oml.Scheme(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[oml.GoalDefType](p2, scalaxb.ElemName(node) :: stack),
        p3.toSeq map { scalaxb.fromXML[oml.Mission](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@monitoring-scheme").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: oml.Scheme, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.monitoringscheme foreach { x => attr = scala.xml.Attribute(null, "monitoring-scheme", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Scheme, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[oml.GoalDefType](__obj.goal, targetNamespace, Some("goal"), __scope, false),
        __obj.mission flatMap { scalaxb.toXML[oml.Mission](_, targetNamespace, Some("mission"), __scope, false) })

  }

  trait DefaultomlFsTypeFormat extends scalaxb.ElemNameParser[oml.FsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("fsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.FsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "scheme")) ^^
      { case p1 ~ p2 =>
      oml.FsType(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.Scheme](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: oml.FsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.scheme flatMap { scalaxb.toXML[oml.Scheme](_, targetNamespace, Some("scheme"), __scope, false) })

  }

  trait DefaultomlNormFormat extends scalaxb.XMLFormat[oml.Norm] with scalaxb.CanWriteChildNodes[oml.Norm] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Norm] = seq match {
      case node: scala.xml.Node => Right(oml.Norm(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@condition").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@role"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@mission"), scalaxb.ElemName(node) :: stack),
        (node \ "@time-constraint").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Norm, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.condition foreach { x => attr = scala.xml.Attribute(null, "condition", x.toString, attr) }
      attr = scala.xml.Attribute(null, "role", __obj.role.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr = scala.xml.Attribute(null, "mission", __obj.mission.toString, attr)
      __obj.timeconstraint foreach { x => attr = scala.xml.Attribute(null, "time-constraint", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Norm, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlNsTypeFormat extends scalaxb.ElemNameParser[oml.NsType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("nsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.NsType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "norm")) ^^
      { case p1 ~ p2 =>
      oml.NsType(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.Norm](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: oml.NsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.norm flatMap { scalaxb.toXML[oml.Norm](_, targetNamespace, Some("norm"), __scope, false) })

  }

  trait DefaultomlPropertyFormat extends scalaxb.XMLFormat[oml.Property] with scalaxb.CanWriteChildNodes[oml.Property] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Property] = seq match {
      case node: scala.xml.Node => Right(oml.Property(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@value"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Property, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.Property, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlPropertiesTypeFormat extends scalaxb.ElemNameParser[oml.PropertiesType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("propertiesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.PropertiesType] =
      rep(((scalaxb.ElemName(targetNamespace, "property"))) ^^ 
        { case p1 => oml.PropertiesTypeSequence1(scalaxb.fromXML[oml.Property](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      oml.PropertiesType(p1.toSeq: _*) }
    
    def writesChildNodes(__obj: oml.PropertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.propertiestypesequence1 flatMap { scalaxb.toXML[oml.PropertiesTypeSequence1](_, None, Some("propertiestypesequence1"), __scope, false) })

  }

  trait DefaultomlPropertiesTypeSequence1Format extends scalaxb.XMLFormat[oml.PropertiesTypeSequence1] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.PropertiesTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: oml.PropertiesTypeSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[oml.Property](__obj.property, targetNamespace, Some("property"), __scope, false)


  }

  trait DefaultomlExtendsFormat extends scalaxb.XMLFormat[oml.Extends] with scalaxb.CanWriteChildNodes[oml.Extends] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Extends] = seq match {
      case node: scala.xml.Node => Right(oml.Extends((node \ "@role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Extends, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.role foreach { x => attr = scala.xml.Attribute(null, "role", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Extends, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlRoleDefTypeFormat extends scalaxb.ElemNameParser[oml.RoleDefType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("roleDefType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.RoleDefType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "extends")) ^^
      { case p1 ~ p2 =>
      oml.RoleDefType(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.Extends](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) }
    
    override def writesAttribute(__obj: oml.RoleDefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.RoleDefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.extendsValue flatMap { scalaxb.toXML[oml.Extends](_, targetNamespace, Some("extends"), __scope, false) })

  }

  def buildomlScopeTypeFormat = new DefaultomlScopeTypeFormat {}
  trait DefaultomlScopeTypeFormat extends scalaxb.XMLFormat[oml.ScopeType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.ScopeType] =
      Right(oml.ScopeType.fromString(seq.text))
    
    def writes(__obj: oml.ScopeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildomlCardinalityObjectTypeFormat = new DefaultomlCardinalityObjectTypeFormat {}
  trait DefaultomlCardinalityObjectTypeFormat extends scalaxb.XMLFormat[oml.CardinalityObjectType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.CardinalityObjectType] =
      Right(oml.CardinalityObjectType.fromString(seq.text))
    
    def writes(__obj: oml.CardinalityObjectType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultomlRoleFormat extends scalaxb.XMLFormat[oml.Role] with scalaxb.CanWriteChildNodes[oml.Role] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Role] = seq match {
      case node: scala.xml.Node => Right(oml.Role((node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Role, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Role, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlRolesFormat extends scalaxb.ElemNameParser[oml.Roles] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Roles] =
      rep(scalaxb.ElemName(targetNamespace, "role")) ^^
      { case p1 =>
      oml.Roles(p1.toSeq map { scalaxb.fromXML[oml.Role](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: oml.Roles, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.role flatMap { scalaxb.toXML[oml.Role](_, targetNamespace, Some("role"), __scope, false) })

  }

  trait DefaultomlLinkFormat extends scalaxb.XMLFormat[oml.Link] with scalaxb.CanWriteChildNodes[oml.Link] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Link] = seq match {
      case node: scala.xml.Node => Right(oml.Link((node \ "@from").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@to").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@scope").headOption map { scalaxb.fromXML[oml.ScopeType](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[oml.ScopeType](scala.xml.Text("intra-group"), scalaxb.ElemName(node) :: stack) },
        (node \ "@extends-sub-groups").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@bi-dir").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Link, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.from foreach { x => attr = scala.xml.Attribute(null, "from", x.toString, attr) }
      __obj.to foreach { x => attr = scala.xml.Attribute(null, "to", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      if (__obj.scope.toString != "intra-group") attr = scala.xml.Attribute(null, "scope", __obj.scope.toString, attr)
      if (__obj.extendssubgroups.toString != "false") attr = scala.xml.Attribute(null, "extends-sub-groups", __obj.extendssubgroups.toString, attr)
      if (__obj.bidir.toString != "false") attr = scala.xml.Attribute(null, "bi-dir", __obj.bidir.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.Link, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlLinksFormat extends scalaxb.ElemNameParser[oml.Links] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Links] =
      rep(scalaxb.ElemName(targetNamespace, "link")) ^^
      { case p1 =>
      oml.Links(p1.toSeq map { scalaxb.fromXML[oml.Link](_, scalaxb.ElemName(node) :: stack) }: _*) }
    
    def writesChildNodes(__obj: oml.Links, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.link flatMap { scalaxb.toXML[oml.Link](_, targetNamespace, Some("link"), __scope, false) })

  }

  trait DefaultomlIncludegroupspecificationFormat extends scalaxb.XMLFormat[oml.Includegroupspecification] with scalaxb.CanWriteChildNodes[oml.Includegroupspecification] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Includegroupspecification] = seq match {
      case node: scala.xml.Node => Right(oml.Includegroupspecification((node \ "@uri").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Includegroupspecification, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.uri foreach { x => attr = scala.xml.Attribute(null, "uri", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Includegroupspecification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlSubgroupsFormat extends scalaxb.ElemNameParser[oml.Subgroups] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Subgroups] =
      rep(scalaxb.ElemName(targetNamespace, "include-group-specification")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "group-specification")) ^^
      { case p1 ~ p2 =>
      oml.Subgroups(p1.toSeq map { scalaxb.fromXML[oml.Includegroupspecification](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.GroupSpecificationType](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: oml.Subgroups, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.includegroupspecification flatMap { scalaxb.toXML[oml.Includegroupspecification](_, targetNamespace, Some("include-group-specification"), __scope, false) },
        __obj.groupspecification flatMap { scalaxb.toXML[oml.GroupSpecificationType](_, targetNamespace, Some("group-specification"), __scope, false) })

  }

  trait DefaultomlCardinalityFormat extends scalaxb.XMLFormat[oml.Cardinality] with scalaxb.CanWriteChildNodes[oml.Cardinality] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Cardinality] = seq match {
      case node: scala.xml.Node => Right(oml.Cardinality((node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[oml.CardinalityObjectType]((node \ "@object"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Cardinality, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      attr = scala.xml.Attribute(null, "object", __obj.objectValue.toString, attr)
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: oml.Cardinality, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlCompatibilityFormat extends scalaxb.XMLFormat[oml.Compatibility] with scalaxb.CanWriteChildNodes[oml.Compatibility] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.Compatibility] = seq match {
      case node: scala.xml.Node => Right(oml.Compatibility(scalaxb.fromXML[String]((node \ "@from"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@to"), scalaxb.ElemName(node) :: stack),
        (node \ "@scope").headOption map { scalaxb.fromXML[oml.ScopeType](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[oml.ScopeType](scala.xml.Text("intra-group"), scalaxb.ElemName(node) :: stack) },
        (node \ "@extends-sub-groups").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@bi-dir").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.Compatibility, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "from", __obj.from.toString, attr)
      attr = scala.xml.Attribute(null, "to", __obj.to.toString, attr)
      if (__obj.scope.toString != "intra-group") attr = scala.xml.Attribute(null, "scope", __obj.scope.toString, attr)
      if (__obj.extendssubgroups.toString != "false") attr = scala.xml.Attribute(null, "extends-sub-groups", __obj.extendssubgroups.toString, attr)
      if (__obj.bidir.toString != "false") attr = scala.xml.Attribute(null, "bi-dir", __obj.bidir.toString, attr)
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.Compatibility, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultomlFormationconstraintsFormat extends scalaxb.ElemNameParser[oml.Formationconstraints] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.Formationconstraints] =
      rep(scalaxb.ElemName(targetNamespace, "cardinality")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "compatibility")) ^^
      { case p1 ~ p2 =>
      oml.Formationconstraints(p1.toSeq map { scalaxb.fromXML[oml.Cardinality](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.Compatibility](_, scalaxb.ElemName(node) :: stack) }) }
    
    def writesChildNodes(__obj: oml.Formationconstraints, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.cardinality flatMap { scalaxb.toXML[oml.Cardinality](_, targetNamespace, Some("cardinality"), __scope, false) },
        __obj.compatibility flatMap { scalaxb.toXML[oml.Compatibility](_, targetNamespace, Some("compatibility"), __scope, false) })

  }

  trait DefaultomlGroupSpecificationTypeFormat extends scalaxb.ElemNameParser[oml.GroupSpecificationType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("groupSpecificationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.GroupSpecificationType] =
      opt(scalaxb.ElemName(targetNamespace, "roles")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "links")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "sub-groups")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "formation-constraints")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      oml.GroupSpecificationType(p1.headOption map { scalaxb.fromXML[oml.Roles](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[oml.Links](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[oml.Subgroups](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[oml.Formationconstraints](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@max").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@monitoring-scheme").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: oml.GroupSpecificationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
      __obj.monitoringscheme foreach { x => attr = scala.xml.Attribute(null, "monitoring-scheme", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.GroupSpecificationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.roles map { scalaxb.toXML[oml.Roles](_, targetNamespace, Some("roles"), __scope, false) } getOrElse {Nil},
        __obj.links map { scalaxb.toXML[oml.Links](_, targetNamespace, Some("links"), __scope, false) } getOrElse {Nil},
        __obj.subgroups flatMap { scalaxb.toXML[oml.Subgroups](_, targetNamespace, Some("sub-groups"), __scope, false) },
        __obj.formationconstraints map { scalaxb.toXML[oml.Formationconstraints](_, targetNamespace, Some("formation-constraints"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultomlPlanTypeFormat extends scalaxb.ElemNameParser[oml.PlanType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("planType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.PlanType] =
      opt(scalaxb.ElemName(targetNamespace, "properties")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "goal")) ^^
      { case p1 ~ p2 =>
      oml.PlanType(p1.headOption map { scalaxb.fromXML[oml.PropertiesType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[oml.GoalDefType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[oml.PlanOperatorType]((node \ "@operator"), scalaxb.ElemName(node) :: stack),
        (node \ "@success-rate").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: oml.PlanType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "operator", __obj.operator.toString, attr)
      __obj.successrate foreach { x => attr = scala.xml.Attribute(null, "success-rate", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.PlanType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.properties map { scalaxb.toXML[oml.PropertiesType](_, targetNamespace, Some("properties"), __scope, false) } getOrElse {Nil},
        __obj.goal flatMap { scalaxb.toXML[oml.GoalDefType](_, targetNamespace, Some("goal"), __scope, false) })

  }

  trait DefaultomlGoalDefTypeFormat extends scalaxb.ElemNameParser[oml.GoalDefType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    override def typeName: Option[String] = Some("goalDefType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[oml.GoalDefType] =
      rep(scalaxb.ElemName(targetNamespace, "argument")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "plan")) ^^
      { case p1 ~ p2 =>
      oml.GoalDefType(p1.toSeq map { scalaxb.fromXML[oml.ArgumentType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[oml.PlanType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@min").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ds").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[oml.GoalType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ttf").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }
    
    override def writesAttribute(__obj: oml.GoalDefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
      __obj.ds foreach { x => attr = scala.xml.Attribute(null, "ds", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.ttf foreach { x => attr = scala.xml.Attribute(null, "ttf", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.GoalDefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.argument flatMap { scalaxb.toXML[oml.ArgumentType](_, targetNamespace, Some("argument"), __scope, false) },
        __obj.plan map { scalaxb.toXML[oml.PlanType](_, targetNamespace, Some("plan"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultomlArgumentTypeFormat extends scalaxb.XMLFormat[oml.ArgumentType] with scalaxb.CanWriteChildNodes[oml.ArgumentType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.ArgumentType] = seq match {
      case node: scala.xml.Node => Right(oml.ArgumentType(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@value").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: oml.ArgumentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.value foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: oml.ArgumentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildomlPlanOperatorTypeFormat = new DefaultomlPlanOperatorTypeFormat {}
  trait DefaultomlPlanOperatorTypeFormat extends scalaxb.XMLFormat[oml.PlanOperatorType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.PlanOperatorType] =
      Right(oml.PlanOperatorType.fromString(seq.text))
    
    def writes(__obj: oml.PlanOperatorType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildomlGoalTypeFormat = new DefaultomlGoalTypeFormat {}
  trait DefaultomlGoalTypeFormat extends scalaxb.XMLFormat[oml.GoalType] {
    val targetNamespace: Option[String] = Some("http://moise.sourceforge.net/os")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, oml.GoalType] =
      Right(oml.GoalType.fromString(seq.text))
    
    def writes(__obj: oml.GoalType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }


}

